from typing import Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, Field

from backend.core.cell import CellType


class InvestigationStep(BaseModel):
    """A single step in an investigation plan"""
    step_id: int
    description: str
    cell_type: CellType
    content: str
    depends_on: List[int] = Field(default_factory=list)


class InvestigationPlan(BaseModel):
    """
    A structured plan for investigating a query
    Generated by the AI agent to break down complex questions
    """
    query: str
    steps: List[InvestigationStep] = Field(default_factory=list)
    thinking: Optional[str] = None


class PlanExecutionState(BaseModel):
    """Tracks the execution state of an investigation plan"""
    plan: InvestigationPlan
    step_to_cell_map: Dict[int, UUID] = Field(default_factory=dict)
    completed_steps: List[int] = Field(default_factory=list)
    current_step: Optional[int] = None
    
    def get_next_executable_step(self) -> Optional[InvestigationStep]:
        """
        Get the next step that can be executed based on dependencies
        
        Returns:
            The next executable step, or None if no steps are ready
        """
        for step in self.plan.steps:
            # Skip completed steps
            if step.step_id in self.completed_steps:
                continue
            
            # Check if all dependencies are completed
            deps_satisfied = all(dep in self.completed_steps for dep in step.depends_on)
            if deps_satisfied:
                return step
        
        return None
    
    def mark_step_completed(self, step_id: int) -> None:
        """Mark a step as completed"""
        if step_id not in self.completed_steps:
            self.completed_steps.append(step_id)
        
        if self.current_step == step_id:
            self.current_step = None
    
    def set_current_step(self, step_id: int) -> None:
        """Set the current step being executed"""
        self.current_step = step_id
    
    def is_complete(self) -> bool:
        """Check if all steps in the plan have been completed"""
        return set(self.completed_steps) == {step.step_id for step in self.plan.steps}
    
    def map_step_to_cell(self, step_id: int, cell_id: UUID) -> None:
        """Map a step ID to a cell ID"""
        self.step_to_cell_map[step_id] = cell_id
    
    def get_cell_for_step(self, step_id: int) -> Optional[UUID]:
        """Get the cell ID for a step"""
        return self.step_to_cell_map.get(step_id)


class PlanAdapter:
    """
    Adapts plans from different formats to the internal InvestigationPlan format
    """
    @staticmethod
    def from_dict(data: Dict) -> InvestigationPlan:
        """Convert a dictionary (e.g., from AI output) to an InvestigationPlan"""
        steps = []
        
        for step_data in data.get("steps", []):
            # Convert cell_type from string to enum
            cell_type_str = step_data.get("cell_type", "markdown").upper()
            try:
                cell_type = CellType[cell_type_str]
            except KeyError:
                # Default to markdown if type is unknown
                cell_type = CellType.MARKDOWN
            
            step = InvestigationStep(
                step_id=step_data.get("step_id", len(steps) + 1),
                description=step_data.get("description", ""),
                cell_type=cell_type,
                content=step_data.get("content", ""),
                depends_on=step_data.get("depends_on", [])
            )
            steps.append(step)
        
        return InvestigationPlan(
            query=data.get("query", ""),
            steps=steps,
            thinking=data.get("thinking")
        )
    
    @staticmethod
    def to_dict(plan: InvestigationPlan) -> Dict:
        """Convert an InvestigationPlan to a dictionary"""
        return {
            "query": plan.query,
            "steps": [
                {
                    "step_id": step.step_id,
                    "description": step.description,
                    "cell_type": step.cell_type.value.lower(),
                    "content": step.content,
                    "depends_on": step.depends_on
                }
                for step in plan.steps
            ],
            "thinking": plan.thinking
        }